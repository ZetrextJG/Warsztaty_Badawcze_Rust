#Inicjalizacja
1. Część funkcja inicjuąca ma być randomowa
2. czesc jakies suboptymalne juz rozwiazanie - pomysl parametr jaką częścią są 
suboptymalne
3. temperatura z przedzialu (min,max) - parametry do przetestowania+  jaki rozkład 
temperatury (wstepnie jednostajny) ( może mini+(max-min)*beta(a,b))
4. tablica is_shuffle: bool - parametr prawdopodobieństwo które wybieramy czy 2 opt 
czy permutacja


#Metropolis 
1.Ustalić paramtery dla zamieniania maksymalna długośc scieżki - % liczby miast max 
30%
						scieżka i macierz dystansów 

2. Jak wybierane są scieżki: wybieramy 2 punkty, robimy od każdego ścieżke długości: 
dlugosc_sciezki o ile to mozliwe, liczymy odległośc między tymi punktamy liczona  w 
miastach; jeżeli obie da sie długości dlugosc_sciezki to idą "w prawo" o tą długośc 
jeżeli się nie da to sciezka od mniejszego punktu idzie w lewo 	przepisujemy z 
zawijaniem

# lista dlugosci 20 sciezka
# sciezka dlugosci 4
# t1=5
# t2=18
# opty
# sciekza[5:5+4%dlugosci], sciezka[18:18+4%dlugosc] = sciezka[18:18+4%dlugosc], sciekza[5:5+4%dlugosci]

# alternatywnie opty
# for i, j in zip(range(5,5+4),range(18,18+4))
#     sciekza[i%dlugosci], sciazka[j%dlugosc] = sciazka[j%dlugosc], sciekza[i%dlugosci]



3. permutacje
 sciezka[18:18+4%dlugosc] = sciezka[18:18+4%dlugosc].shuffle()


# Replica Transition
1.swap_prob - globalny paramter głównej funcji
2. zamieniamy kazde ma szanse wymienic sie z kazdym,ilosc_miast razy losujemy 2 indeksy i z z 
prawdopodobienstwem swap_prob losujemy czy sie zamieniają


Powtarzamy #Metropolis i #Replica Transition k razy- parametr 
i przechodzimy do fazy chłodzenia kazdego ze stanow

